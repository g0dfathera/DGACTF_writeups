
![[Pasted image 20250517151739.png]]

მოცემული გვაქვს ფაილი გაფართოების გარეშე.

```
0b7133f8221d6e70cbec445196b7cf5d5ac5bc55518ac896_sick
```

პირველ რიგში, გავიგოთ ფაილის ტიპი - რისთვისაც გამოვიყენებ file command-ს ლინუქსში

![[Pasted image 20250517152045.png]]

თუ თასქის სახელს და დავალებას გავითვალისწინებთ, ეს ფაილი ELF (Executable and Linkable Format) ტიპის უნდა იყოს, თუმცა ასე არ არის.

ყოველი შემთხვევისთვის ვნახოთ strings.

![[Pasted image 20250517152313.png]]

strings-მა გვაჩვენა, რომ flag კოდირებულია, შესაბამისად, ამ ფაილის გაშვების შემდეგ უნდა მოგვცეს დეკოდირებული flag.

მივუბრუნდეთ ფაილის გაფართოებას, ზოგადად, პირველ ბაიტებში არის ინფორმაცია ფაილის "ELF-ობის" შესახებ:

```
7f 45 4c 46    -->    .ELF

```

ზუსტად ასე უნდა იწყებოდეს hex.

![[Pasted image 20250517152808.png]]

როგორც ხედავთ, პირველი ბაიტები ცარიელია. ამიტომ მოგვიწევს ხელით ჩავწეროთ.

![[Pasted image 20250517153103.png]]

კარგი, როგორც ჩანს ერთი პრობლემა მოვიშორეთ, უფრო კარგად რომ გაიგოთ რა ხდება, აგიხსნით როგორ მუშაობს ზოგადად ELF.

```
Offset  Bytes          Description
0x00    7f 45 4c 46    Magic Number: \x7fELF
0x04    02             Class: 64-bit (01 = 32-bit, 02 = 64-bit)
0x05    01             Data: Little Endian (01 = LE, 02 = BE)
0x06    01             Version: 1
0x07    00             OS ABI: System V
0x08    00             ABI Version
0x09    00...          Padding
```

ასე გამოიყურება ELF ფაილის პირველი 16 ბაიტი. სადაც გაწერილია ინფორმაცია ფაილის შესახებ.

ჩვენს შემთხვევაში Header (Magic Number) გავწერეთ, მაგრამ დარჩა class-ის და endianness-ის ბაიტები, რომლებიც, როგორც აღმოჩნდაა არასწორადაა გაწერილი.

ფაილის პირველადი მდგომარეობის აღსადგენად თავიდან გავწეროთ პირველი 16 ბაიტი.

![[Pasted image 20250517153702.png]]

ფაილი სრულად აღდგენილია! ახლა საჭიროა გავხადოთ ის executable და გავუშვათ.

![[Pasted image 20250517153805.png]]